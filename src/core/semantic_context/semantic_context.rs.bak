//! # Semantic Context Extraction
//!
//! This module provides semantic context extraction capabilities for IDE diagnostics,
//! enabling AI assistants to better understand and provide fixes for coding errors.
//!
//! ## Key Components
//!
//! - **SemanticContext**: Core data structure containing all contextual information
//! - **ContextExtractor**: Multi-language parser-based context extraction engine
//! - **Language Detection**: Automatic language detection from file extensions
//! - **Context Filtering**: Relevance scoring and context optimization
//!
//! ## Supported Languages
//!
//! - TypeScript/JavaScript (via tree-sitter-typescript)
//! - Rust (via tree-sitter-rust)  
//! - Python (via tree-sitter-python)
//!
//! ## Usage Examples
//!
//! ```rust
//! use lsp_bridge::core::semantic_context::ContextExtractor;
//! use lsp_bridge::core::types::Diagnostic;
//!
//! // Create a context extractor with built-in parsers
//! let mut extractor = ContextExtractor::new()?;
//!
//! // Extract context for a diagnostic
//! let context = extractor.extract_context_from_file(&diagnostic)?;
//!
//! // Access extracted information
//! if let Some(function) = &context.function_context {
//!     println!("Error in function: {}", function.name);
//! }
//!
//! if let Some(class) = &context.class_context {
//!     println!("Error in class: {}", class.name);
//! }
//!
//! // Use relevance score for prioritization
//! println!("Context relevance: {:.2}", context.relevance_score);
//! ```
//!
//! ## Context Elements
//!
//! The semantic context includes multiple layers of information:
//!
//! - **Function Context**: Complete function signature and body where the error occurs
//! - **Class Context**: Class/struct/interface definition containing the error
//! - **Import Context**: Relevant imports and module dependencies
//! - **Type Definitions**: Custom types referenced in the diagnostic
//! - **Local Variables**: Variables in scope at the error location
//! - **Call Hierarchy**: Function calls to and from the error location
//! - **Dependencies**: Cross-file dependencies and references
//!
//! ## Performance Characteristics
//!
//! - **Parser Initialization**: ~50ms per language (one-time cost)
//! - **Context Extraction**: ~5-20ms per diagnostic depending on file size
//! - **Memory Usage**: ~10-50MB for parser state, scales with file count
//! - **Concurrency**: Thread-safe after initialization, parsers are exclusive-access
//!
//! ## Error Handling
//!
//! This module can return the following errors:
//! - `anyhow::Error` - Parser initialization failures
//! - `anyhow::Error` - File reading failures
//! - `anyhow::Error` - Parse tree construction failures
//!
//! Most errors are gracefully handled by returning default/empty context rather than
//! failing the entire operation.

use super::types::Diagnostic;
use crate::parser_analyzer;
use anyhow::{anyhow, Context, Result};
use std::fs;
use std::path::Path;
use tree_sitter::Node;

/// Semantic context around a diagnostic
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct SemanticContext {
    /// The complete function/method containing the diagnostic
    pub function_context: Option<FunctionContext>,
    /// The class/struct/interface containing the diagnostic
    pub class_context: Option<ClassContext>,
    /// Relevant imports/uses for understanding the error
    pub imports: Vec<ImportContext>,
    /// Type definitions referenced in the diagnostic
    pub type_definitions: Vec<TypeDefinition>,
    /// Variables in scope at the diagnostic location
    pub local_variables: Vec<VariableContext>,
    /// Call hierarchy information (functions called from/calling this location)
    pub call_hierarchy: CallHierarchy,
    /// Cross-file dependencies relevant to this diagnostic
    pub dependencies: Vec<DependencyInfo>,
    /// Confidence score for context relevance (0.0-1.0)
    pub relevance_score: f32,
    /// Surrounding code snippets for additional context
    pub surrounding_code: std::collections::HashMap<String, String>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct FunctionContext {
    pub name: String,
    pub signature: String,
    pub body: String,
    pub start_line: u32,
    pub end_line: u32,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ClassContext {
    pub name: String,
    pub kind: String, // class, struct, interface, trait
    pub definition: String,
    pub start_line: u32,
    pub end_line: u32,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ImportContext {
    pub statement: String,
    pub imported_names: Vec<String>,
    pub source: Option<String>,
    pub line: u32,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct TypeDefinition {
    pub name: String,
    pub definition: String,
    pub kind: String, // type, interface, class, struct
    pub line: u32,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct VariableContext {
    pub name: String,
    pub type_annotation: Option<String>,
    pub initialization: Option<String>,
    pub line: u32,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CallHierarchy {
    /// Functions called from the diagnostic location
    pub calls_outgoing: Vec<FunctionCall>,
    /// Functions that call the function containing the diagnostic
    pub calls_incoming: Vec<FunctionCall>,
    /// Depth of call stack analysis performed
    pub analysis_depth: u32,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct FunctionCall {
    pub function_name: String,
    pub call_site_line: u32,
    pub arguments: Vec<String>,
    pub return_type: Option<String>,
    /// File containing this function call (for cross-file calls)
    pub file_path: Option<String>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct DependencyInfo {
    pub file_path: String,
    pub dependency_type: DependencyType,
    pub symbols_used: Vec<String>,
    pub line_range: Option<(u32, u32)>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub enum DependencyType {
    /// Direct import/use statement
    Import,
    /// Type definition referenced in error
    TypeReference,
    /// Function called from error location
    FunctionCall,
    /// Variable referenced from outer scope
    VariableReference,
}

// Apply parser_analyzer macro to ContextExtractor
parser_analyzer! {
    /// Extracts semantic context from source code using multiple language parsers
    pub struct ContextExtractor {
        parsers: {
            typescript => tree_sitter_typescript::language_typescript(),
            rust => tree_sitter_rust::language(),
            python => tree_sitter_python::language()
        }
    }
}

impl ContextExtractor {
    /// Extract semantic context for a diagnostic
    pub fn extract_context(
        &mut self,
        diagnostic: &Diagnostic,
        file_content: &str,
    ) -> Result<SemanticContext> {
        let language = self.detect_language(&diagnostic.file);

        let tree = match language {
            Language::TypeScript => {
                if let Some(parser) = self.get_parser("typescript") {
                    parser.parse(file_content, None)
                } else {
                    return Ok(SemanticContext::default());
                }
            }
            Language::Rust => {
                if let Some(parser) = self.get_parser("rust") {
                    parser.parse(file_content, None)
                } else {
                    return Ok(SemanticContext::default());
                }
            }
            Language::Python => {
                if let Some(parser) = self.get_parser("python") {
                    parser.parse(file_content, None)
                } else {
                    return Ok(SemanticContext::default());
                }
            }
            _ => return Ok(SemanticContext::default()),
        };

        let tree = tree.ok_or_else(|| anyhow!("Failed to parse source file"))?;
        let root_node = tree.root_node();

        // Find the node at the diagnostic location
        let diagnostic_node = self.find_node_at_position(
            root_node,
            diagnostic.range.start.line,
            diagnostic.range.start.character,
            file_content,
        );

        let mut context = SemanticContext::default();

        // Extract various context elements
        if let Some(node) = diagnostic_node {
            context.function_context = self.find_enclosing_function(&node, file_content, language);
            context.class_context = self.find_enclosing_class(&node, file_content, language);
            context.imports = self.extract_imports(root_node, file_content, language);
            context.type_definitions =
                self.extract_type_definitions(root_node, file_content, language);
            context.local_variables = self.extract_local_variables(&node, file_content, language);

            // Enhanced features for V2
            context.call_hierarchy = self.extract_call_hierarchy(&node, file_content, language);
            context.dependencies =
                self.extract_dependencies(&node, file_content, language, &diagnostic.file);
            // Apply filtering with enhanced heuristics
            context = self.filter_relevant_types(context, diagnostic);
            context.relevance_score = self.calculate_relevance_score(&context);
        }

        Ok(context)
    }

    /// Load file content and extract context
    pub fn extract_context_from_file(
        &mut self,
        diagnostic: &Diagnostic,
    ) -> Result<SemanticContext> {
        let file_content = fs::read_to_string(&diagnostic.file)
            .with_context(|| format!("Failed to read file: {}", diagnostic.file))?;
        self.extract_context(diagnostic, &file_content)
    }

    fn detect_language(&self, file_path: &str) -> Language {
        match Path::new(file_path)
            .extension()
            .and_then(|ext| ext.to_str())
        {
            Some("ts") | Some("tsx") => Language::TypeScript,
            Some("js") | Some("jsx") => Language::TypeScript,
            Some("rs") => Language::Rust,
            Some("py") => Language::Python,
            _ => Language::Unknown,
        }
    }

    fn find_node_at_position<'a>(
        &self,
        root: Node<'a>,
        line: u32,
        column: u32,
        _source: &str,
    ) -> Option<Node<'a>> {
        let mut cursor = root.walk();
        let mut result = None;

        loop {
            let node = cursor.node();
            let start = node.start_position();
            let end = node.end_position();

            if start.row <= line as usize && end.row >= line as usize {
                if start.row == line as usize && start.column > column as usize {
                    break;
                }
                if end.row == line as usize && end.column < column as usize {
                    break;
                }

                result = Some(node);

                if !cursor.goto_first_child() {
                    break;
                }
            } else if !cursor.goto_next_sibling() {
                break;
            }
        }

        result
    }

    fn find_enclosing_function(
        &self,
        node: &Node,
        source: &str,
        language: Language,
    ) -> Option<FunctionContext> {
        let mut current = Some(*node);

        while let Some(n) = current {
            let kind = n.kind();

            let is_function = match language {
                Language::TypeScript => {
                    matches!(kind, "function_declaration" | "method_definition" | 
                            "arrow_function" | "function_expression") ||
                    // Check if this is a variable declaration containing an arrow function
                    (kind == "variable_declarator" && self.contains_arrow_function(&n, source)) ||
                    // Check if this is a lexical declaration (const/let) containing a function
                    (kind == "lexical_declaration" && self.contains_arrow_function(&n, source))
                }
                Language::Rust => {
                    matches!(kind, "function_item" | "impl_item")
                }
                Language::Python => {
                    matches!(kind, "function_definition")
                }
                _ => false,
            };

            if is_function {
                return self.extract_function_context(&n, source, language);
            }

            current = n.parent();
        }

        None
    }

    fn contains_arrow_function(&self, node: &Node, source: &str) -> bool {
        // Recursively check if this node or any of its descendants contains an arrow function
        self.contains_arrow_function_recursive(node, source)
    }

    fn contains_arrow_function_recursive(&self, node: &Node, source: &str) -> bool {
        // Check current node
        if node.kind() == "arrow_function" {
            return true;
        }

        // Check for useCallback, useEffect, etc. patterns
        if node.kind() == "call_expression" {
            if let Some(function_name) = node.child(0) {
                let function_text = &source[function_name.start_byte()..function_name.end_byte()];
                if function_text.starts_with("useCallback") || function_text.starts_with("useMemo")
                {
                    return true;
                }
            }
        }

        // Recursively check children
        let mut cursor = node.walk();
        for child in node.children(&mut cursor) {
            if self.contains_arrow_function_recursive(&child, source) {
                return true;
            }
        }

        false
    }

    fn extract_function_context(
        &self,
        node: &Node,
        source: &str,
        language: Language,
    ) -> Option<FunctionContext> {
        let name = match language {
            Language::TypeScript => {
                if node.kind() == "variable_declarator" {
                    // For variable declarators like: const handleUserClick = useCallback(...)
                    node.child_by_field_name("name")
                        .and_then(|n| n.utf8_text(source.as_bytes()).ok())
                        .unwrap_or("anonymous")
                        .to_string()
                } else if node.kind() == "lexical_declaration" {
                    // For lexical declarations, get the name from the first variable declarator
                    node.children(&mut node.walk())
                        .find(|child| child.kind() == "variable_declarator")
                        .and_then(|declarator| declarator.child_by_field_name("name"))
                        .and_then(|n| n.utf8_text(source.as_bytes()).ok())
                        .unwrap_or("anonymous")
                        .to_string()
                } else {
                    node.child_by_field_name("name")
                        .and_then(|n| n.utf8_text(source.as_bytes()).ok())
                        .unwrap_or("anonymous")
                        .to_string()
                }
            }
            Language::Rust => node
                .child_by_field_name("name")
                .and_then(|n| n.utf8_text(source.as_bytes()).ok())
                .unwrap_or("anonymous")
                .to_string(),
            Language::Python => node
                .child_by_field_name("name")
                .and_then(|n| n.utf8_text(source.as_bytes()).ok())
                .unwrap_or("anonymous")
                .to_string(),
            _ => "unknown".to_string(),
        };

        let signature = self.extract_function_signature(node, source, language);
        let body = node.utf8_text(source.as_bytes()).ok()?.to_string();

        Some(FunctionContext {
            name,
            signature,
            body,
            start_line: node.start_position().row as u32,
            end_line: node.end_position().row as u32,
        })
    }

    fn extract_function_signature(&self, node: &Node, source: &str, language: Language) -> String {
        match language {
            Language::TypeScript => {
                // Extract up to the opening brace
                if let Some(body) = node.child_by_field_name("body") {
                    let start = node.start_byte();
                    let end = body.start_byte();
                    source[start..end].trim().to_string()
                } else {
                    node.utf8_text(source.as_bytes()).unwrap_or("").to_string()
                }
            }
            Language::Rust => {
                // Similar extraction for Rust
                if let Some(body) = node.child_by_field_name("body") {
                    let start = node.start_byte();
                    let end = body.start_byte();
                    source[start..end].trim().to_string()
                } else {
                    node.utf8_text(source.as_bytes()).unwrap_or("").to_string()
                }
            }
            Language::Python => {
                // Extract def line
                let first_line_end = source[node.start_byte()..]
                    .find(':')
                    .map(|i| node.start_byte() + i + 1)
                    .unwrap_or(node.end_byte());
                source[node.start_byte()..first_line_end].to_string()
            }
            _ => String::new(),
        }
    }

    fn find_enclosing_class(
        &self,
        node: &Node,
        source: &str,
        language: Language,
    ) -> Option<ClassContext> {
        let mut current = Some(*node);

        while let Some(n) = current {
            let kind = n.kind();

            let (is_class, class_kind) = match language {
                Language::TypeScript => match kind {
                    "class_declaration" => (true, "class"),
                    "interface_declaration" => (true, "interface"),
                    _ => (false, ""),
                },
                Language::Rust => match kind {
                    "struct_item" => (true, "struct"),
                    "trait_item" => (true, "trait"),
                    "impl_item" => (true, "impl"),
                    _ => (false, ""),
                },
                Language::Python => match kind {
                    "class_definition" => (true, "class"),
                    _ => (false, ""),
                },
                _ => (false, ""),
            };

            if is_class {
                return self.extract_class_context(&n, source, language, class_kind);
            }

            current = n.parent();
        }

        None
    }

    fn extract_class_context(
        &self,
        node: &Node,
        source: &str,
        _language: Language,
        kind: &str,
    ) -> Option<ClassContext> {
        let name = node
            .child_by_field_name("name")
            .and_then(|n| n.utf8_text(source.as_bytes()).ok())
            .unwrap_or("anonymous")
            .to_string();

        let definition = node.utf8_text(source.as_bytes()).ok()?.to_string();

        Some(ClassContext {
            name,
            kind: kind.to_string(),
            definition,
            start_line: node.start_position().row as u32,
            end_line: node.end_position().row as u32,
        })
    }

    fn extract_imports(&self, root: Node, source: &str, language: Language) -> Vec<ImportContext> {
        let mut imports = Vec::new();
        let mut cursor = root.walk();

        let import_kinds = match language {
            Language::TypeScript => vec!["import_statement", "import_clause"],
            Language::Rust => vec!["use_declaration"],
            Language::Python => vec!["import_statement", "import_from_statement"],
            _ => vec![],
        };

        self.visit_nodes(&mut cursor, |node| {
            if import_kinds.contains(&node.kind()) {
                if let Some(import) = self.extract_import_context(&node, source, language) {
                    imports.push(import);
                }
            }
        });

        imports
    }

    fn extract_import_context(
        &self,
        node: &Node,
        source: &str,
        language: Language,
    ) -> Option<ImportContext> {
        let statement = node.utf8_text(source.as_bytes()).ok()?.to_string();
        let line = node.start_position().row as u32;

        // Extract imported names based on language
        let (imported_names, source_module) = match language {
            Language::TypeScript => {
                let names = self.extract_typescript_imports(node, source);
                let module = node
                    .child_by_field_name("source")
                    .and_then(|n| n.utf8_text(source.as_bytes()).ok())
                    .map(|s| s.trim_matches(|c| c == '"' || c == '\'').to_string());
                (names, module)
            }
            Language::Rust => {
                let names = self.extract_rust_imports(node, source);
                (names, None)
            }
            Language::Python => {
                let names = self.extract_python_imports(node, source);
                let module = node
                    .child_by_field_name("module_name")
                    .and_then(|n| n.utf8_text(source.as_bytes()).ok())
                    .map(|s| s.to_string());
                (names, module)
            }
            _ => (vec![], None),
        };

        Some(ImportContext {
            statement,
            imported_names,
            source: source_module,
            line,
        })
    }

    fn extract_typescript_imports(&self, node: &Node, source: &str) -> Vec<String> {
        let mut names = Vec::new();
        let mut cursor = node.walk();

        self.visit_nodes(&mut cursor, |n| {
            if matches!(n.kind(), "identifier" | "import_specifier") {
                if let Ok(name) = n.utf8_text(source.as_bytes()) {
                    if !name.is_empty() && name != "from" && name != "import" {
                        names.push(name.to_string());
                    }
                }
            }
        });

        names
    }

    fn extract_rust_imports(&self, node: &Node, source: &str) -> Vec<String> {
        let mut names = Vec::new();
        let mut cursor = node.walk();

        self.visit_nodes(&mut cursor, |n| {
            if n.kind() == "identifier" {
                if let Ok(name) = n.utf8_text(source.as_bytes()) {
                    if !name.is_empty() && name != "use" && name != "as" {
                        names.push(name.to_string());
                    }
                }
            }
        });

        names
    }

    fn extract_python_imports(&self, node: &Node, source: &str) -> Vec<String> {
        let mut names = Vec::new();
        let mut cursor = node.walk();

        self.visit_nodes(&mut cursor, |n| {
            if matches!(n.kind(), "dotted_name" | "aliased_import") {
                if let Ok(name) = n.utf8_text(source.as_bytes()) {
                    names.push(name.to_string());
                }
            }
        });

        names
    }

    fn extract_type_definitions(
        &self,
        root: Node,
        source: &str,
        language: Language,
    ) -> Vec<TypeDefinition> {
        let mut types = Vec::new();
        let mut cursor = root.walk();

        let type_kinds = match language {
            Language::TypeScript => vec!["type_alias_declaration", "interface_declaration"],
            Language::Rust => vec!["type_alias", "struct_item", "enum_item"],
            Language::Python => vec!["class_definition"], // Python doesn't have explicit type aliases
            _ => vec![],
        };

        self.visit_nodes(&mut cursor, |node| {
            if type_kinds.contains(&node.kind()) {
                if let Some(type_def) = self.extract_type_definition(&node, source, language) {
                    types.push(type_def);
                }
            }
        });

        types
    }

    fn extract_type_definition(
        &self,
        node: &Node,
        source: &str,
        _language: Language,
    ) -> Option<TypeDefinition> {
        let name = node
            .child_by_field_name("name")
            .and_then(|n| n.utf8_text(source.as_bytes()).ok())
            .unwrap_or("anonymous")
            .to_string();

        let definition = node.utf8_text(source.as_bytes()).ok()?.to_string();
        let kind = node.kind().to_string();
        let line = node.start_position().row as u32;

        Some(TypeDefinition {
            name,
            definition,
            kind,
            line,
        })
    }

    fn extract_local_variables(
        &self,
        node: &Node,
        source: &str,
        language: Language,
    ) -> Vec<VariableContext> {
        let mut variables = Vec::new();

        // Find the enclosing function or block
        let mut scope_node = Some(*node);
        while let Some(n) = scope_node {
            if self.is_scope_boundary(&n, language) {
                break;
            }
            scope_node = n.parent();
        }

        if let Some(scope) = scope_node {
            let mut cursor = scope.walk();
            let diagnostic_line = node.start_position().row;

            self.visit_nodes(&mut cursor, |n| {
                // Only include variables declared before the diagnostic
                if n.start_position().row <= diagnostic_line {
                    if let Some(var) = self.extract_variable_context(&n, source, language) {
                        variables.push(var);
                    }
                }
            });
        }

        variables
    }

    fn is_scope_boundary(&self, node: &Node, language: Language) -> bool {
        match language {
            Language::TypeScript => {
                matches!(
                    node.kind(),
                    "function_declaration"
                        | "method_definition"
                        | "arrow_function"
                        | "block_statement"
                )
            }
            Language::Rust => {
                matches!(node.kind(), "function_item" | "block")
            }
            Language::Python => {
                matches!(node.kind(), "function_definition" | "class_definition")
            }
            _ => false,
        }
    }

    fn extract_variable_context(
        &self,
        node: &Node,
        source: &str,
        language: Language,
    ) -> Option<VariableContext> {
        let is_variable = match language {
            Language::TypeScript => {
                matches!(node.kind(), "variable_declaration" | "lexical_declaration")
            }
            Language::Rust => {
                matches!(node.kind(), "let_declaration")
            }
            Language::Python => {
                matches!(node.kind(), "assignment")
            }
            _ => false,
        };

        if !is_variable {
            return None;
        }

        let name = node
            .child_by_field_name("name")
            .or_else(|| node.child_by_field_name("pattern"))
            .and_then(|n| n.utf8_text(source.as_bytes()).ok())
            .unwrap_or("")
            .to_string();

        if name.is_empty() {
            return None;
        }

        let type_annotation = node
            .child_by_field_name("type")
            .and_then(|n| n.utf8_text(source.as_bytes()).ok())
            .map(|s| s.to_string());

        let initialization = node
            .child_by_field_name("value")
            .and_then(|n| n.utf8_text(source.as_bytes()).ok())
            .map(|s| s.to_string());

        Some(VariableContext {
            name,
            type_annotation,
            initialization,
            line: node.start_position().row as u32,
        })
    }

    fn visit_nodes<F>(&self, cursor: &mut tree_sitter::TreeCursor, mut callback: F)
    where
        F: FnMut(Node),
    {
        loop {
            callback(cursor.node());

            if cursor.goto_first_child() {
                continue;
            }

            while !cursor.goto_next_sibling() {
                if !cursor.goto_parent() {
                    return;
                }
            }
        }
    }
    
    /// Extract type references from the current scope
    fn extract_type_references(&self, node: &Node, source: &str, language: Language) -> Vec<(String, u32)> {
        let mut type_refs = Vec::new();
        let mut cursor = node.walk();
        
        match language {
            Language::TypeScript => {
                self.visit_nodes(&mut cursor, |n| {
                    // Type annotations
                    if n.kind() == "type_annotation" {
                        if let Some(type_node) = n.child(1) { // Skip the colon
                            if let Ok(type_name) = type_node.utf8_text(source.as_bytes()) {
                                // Extract just the type name (handle generics, arrays, etc.)
                                let base_type = type_name.split(&['<', '[', ' ', '|', '&'][..])
                                    .next()
                                    .unwrap_or(type_name)
                                    .trim();
                                if !base_type.is_empty() && !self.is_builtin_type(base_type, language) {
                                    type_refs.push((base_type.to_string(), n.start_position().row as u32));
                                }
                            }
                        }
                    }
                    // Type references in expressions
                    else if n.kind() == "type_identifier" {
                        if let Ok(type_name) = n.utf8_text(source.as_bytes()) {
                            if !self.is_builtin_type(type_name, language) {
                                type_refs.push((type_name.to_string(), n.start_position().row as u32));
                            }
                        }
                    }
                    // Generic type arguments
                    else if n.kind() == "type_arguments" {
                        let mut type_cursor = n.walk();
                        self.visit_nodes(&mut type_cursor, |tn| {
                            if tn.kind() == "type_identifier" {
                                if let Ok(type_name) = tn.utf8_text(source.as_bytes()) {
                                    if !self.is_builtin_type(type_name, language) {
                                        type_refs.push((type_name.to_string(), tn.start_position().row as u32));
                                    }
                                }
                            }
                        });
                    }
                });
            }
            Language::Rust => {
                self.visit_nodes(&mut cursor, |n| {
                    // Type identifiers in Rust
                    if matches!(n.kind(), "type_identifier" | "scoped_type_identifier") {
                        if let Ok(type_name) = n.utf8_text(source.as_bytes()) {
                            // Extract the last part of scoped types (e.g., std::vec::Vec -> Vec)
                            let base_type = type_name.split("::").last().unwrap_or(type_name);
                            if !self.is_builtin_type(base_type, language) {
                                type_refs.push((base_type.to_string(), n.start_position().row as u32));
                            }
                        }
                    }
                });
            }
            Language::Python => {
                self.visit_nodes(&mut cursor, |n| {
                    // Type annotations in Python
                    if n.kind() == "type" {
                        if let Ok(type_name) = n.utf8_text(source.as_bytes()) {
                            let base_type = type_name.split('[').next().unwrap_or(type_name).trim();
                            if !self.is_builtin_type(base_type, language) {
                                type_refs.push((base_type.to_string(), n.start_position().row as u32));
                            }
                        }
                    }
                });
            }
            _ => {}
        }
        
        // Deduplicate while preserving first occurrence
        let mut seen = std::collections::HashSet::new();
        type_refs.retain(|(name, _)| seen.insert(name.clone()));
        
        type_refs
    }
    
    /// Check if a type is a built-in type for the language
    fn is_builtin_type(&self, type_name: &str, language: Language) -> bool {
        match language {
            Language::TypeScript => {
                matches!(type_name, "string" | "number" | "boolean" | "void" | "any" | 
                        "unknown" | "never" | "object" | "null" | "undefined" |
                        "Array" | "Promise" | "Map" | "Set" | "Date" | "RegExp" |
                        "Function" | "Error" | "Record" | "Partial" | "Required" |
                        "Readonly" | "Pick" | "Omit")
            }
            Language::Rust => {
                matches!(type_name, "str" | "String" | "bool" | "char" |
                        "i8" | "i16" | "i32" | "i64" | "i128" | "isize" |
                        "u8" | "u16" | "u32" | "u64" | "u128" | "usize" |
                        "f32" | "f64" | "Vec" | "HashMap" | "HashSet" |
                        "Option" | "Result" | "Box" | "Rc" | "Arc" |
                        "Cell" | "RefCell" | "Mutex" | "RwLock")
            }
            Language::Python => {
                matches!(type_name, "int" | "float" | "str" | "bool" | "bytes" |
                        "list" | "dict" | "set" | "tuple" | "None" |
                        "List" | "Dict" | "Set" | "Tuple" | "Optional" |
                        "Union" | "Any" | "Callable" | "Type" | "Generic")
            }
            _ => false
        }
    }

    /// Extract call hierarchy information around the diagnostic location
    fn extract_call_hierarchy(
        &self,
        node: &Node,
        source: &str,
        language: Language,
    ) -> CallHierarchy {
        let mut hierarchy = CallHierarchy::default();

        // Find outgoing calls from the current function or scope
        let scope_node = self
            .find_enclosing_function_node(node, language, source)
            .unwrap_or_else(|| {
                // If not in a function, use the top-level module or a reasonable scope
                let mut current = Some(*node);
                while let Some(n) = current {
                    let parent = n.parent();
                    if parent.is_none() || n.kind() == "program" || n.kind() == "source_file" {
                        return n;
                    }
                    current = parent;
                }
                *node
            });

        hierarchy.calls_outgoing = self.extract_function_calls(&scope_node, source, language);
        hierarchy.analysis_depth = 1;

        hierarchy
    }

    fn find_enclosing_function_node<'a>(
        &self,
        node: &Node<'a>,
        language: Language,
        source: &str,
    ) -> Option<Node<'a>> {
        let mut current = Some(*node);

        while let Some(n) = current {
            let kind = n.kind();

            let is_function = match language {
                Language::TypeScript => {
                    matches!(kind, "function_declaration" | "method_definition" | 
                            "arrow_function" | "function_expression") ||
                    // Check if this is a variable declaration containing an arrow function
                    (kind == "variable_declarator" && self.contains_arrow_function(&n, source)) ||
                    // Check if this is a lexical declaration (const/let) containing a function
                    (kind == "lexical_declaration" && self.contains_arrow_function(&n, source))
                }
                Language::Rust => {
                    matches!(kind, "function_item" | "impl_item")
                }
                Language::Python => {
                    matches!(kind, "function_definition")
                }
                _ => false,
            };

            if is_function {
                return Some(n);
            }

            current = n.parent();
        }

        None
    }

    fn extract_function_calls<'a>(
        &self,
        function_node: &Node<'a>,
        source: &str,
        language: Language,
    ) -> Vec<FunctionCall> {
        let mut calls = Vec::new();
        let mut cursor = function_node.walk();

        let call_kinds = match language {
            Language::TypeScript => vec!["call_expression"],
            Language::Rust => vec!["call_expression"],
            Language::Python => vec!["call"],
            _ => vec![],
        };

        self.visit_nodes(&mut cursor, |node| {
            if call_kinds.contains(&node.kind()) {
                if let Some(call) = self.extract_function_call_info(&node, source, language) {
                    calls.push(call);
                }
            }
        });

        calls
    }

    fn extract_function_call_info(
        &self,
        node: &Node,
        source: &str,
        language: Language,
    ) -> Option<FunctionCall> {
        let function_name = match language {
            Language::TypeScript => node
                .child_by_field_name("function")
                .and_then(|n| n.utf8_text(source.as_bytes()).ok())
                .unwrap_or("unknown")
                .to_string(),
            Language::Rust => node
                .child_by_field_name("function")
                .and_then(|n| n.utf8_text(source.as_bytes()).ok())
                .unwrap_or("unknown")
                .to_string(),
            Language::Python => node
                .child_by_field_name("function")
                .and_then(|n| n.utf8_text(source.as_bytes()).ok())
                .unwrap_or("unknown")
                .to_string(),
            _ => return None,
        };

        let mut arguments = Vec::new();
        if let Some(args_node) = node.child_by_field_name("arguments") {
            let mut cursor = args_node.walk();
            self.visit_nodes(&mut cursor, |n| {
                if matches!(n.kind(), "identifier" | "string" | "number") {
                    if let Ok(arg) = n.utf8_text(source.as_bytes()) {
                        arguments.push(arg.to_string());
                    }
                }
            });
        }

        Some(FunctionCall {
            function_name,
            call_site_line: node.start_position().row as u32,
            arguments,
            return_type: None, // Could be enhanced with type analysis
            file_path: None,   // Current file only for now
        })
    }

    /// Extract cross-file dependencies for the diagnostic
    fn extract_dependencies(
        &self,
        node: &Node,
        source: &str,
        language: Language,
        _current_file: &str,
    ) -> Vec<DependencyInfo> {
        let mut dependencies = Vec::new();

        // Extract import dependencies
        let imports = self.extract_imports(node.parent().unwrap_or(*node), source, language);
        for import in &imports {
            if let Some(ref source_path) = import.source {
                dependencies.push(DependencyInfo {
                    file_path: source_path.clone(),
                    dependency_type: DependencyType::Import,
                    symbols_used: import.imported_names.clone(),
                    line_range: Some((import.line, import.line)),
                });
            }
        }

        // Extract type references in the diagnostic scope
        let type_refs = self.extract_type_references(node, source, language);
        for (type_name, line) in type_refs {
            // Check if this type is imported
            let is_imported = imports.iter().any(|imp| {
                imp.imported_names.contains(&type_name)
            });
            
            if is_imported {
                // Find which import provides this type
                if let Some(import) = imports.iter().find(|imp| imp.imported_names.contains(&type_name)) {
                    if let Some(ref source_path) = import.source {
                        dependencies.push(DependencyInfo {
                            file_path: source_path.clone(),
                            dependency_type: DependencyType::TypeReference,
                            symbols_used: vec![type_name],
                            line_range: Some((line, line)),
                        });
                    }
                }
            }
        }
        
        // Extract function calls that might be from other files
        let function_calls = self.extract_function_calls(node, source, language);
        for call in &function_calls {
            // Check if this function is imported
            let is_imported = imports.iter().any(|imp| {
                imp.imported_names.contains(&call.function_name)
            });
            
            if is_imported {
                // Find which import provides this function
                if let Some(import) = imports.iter().find(|imp| imp.imported_names.contains(&call.function_name)) {
                    if let Some(ref source_path) = import.source {
                        dependencies.push(DependencyInfo {
                            file_path: source_path.clone(),
                            dependency_type: DependencyType::FunctionCall,
                            symbols_used: vec![call.function_name.clone()],
                            line_range: Some((call.call_site_line, call.call_site_line)),
                        });
                    }
                }
            }
        }

        // Deduplicate dependencies by file path and symbol
        let mut unique_deps = std::collections::HashMap::new();
        for dep in dependencies {
            let key = (dep.file_path.clone(), dep.symbols_used.join(","));
            unique_deps.entry(key).or_insert(dep);
        }
        
        unique_deps.into_values().collect()
    }

    /// Filter type definitions to only include those referenced in the diagnostic
    fn filter_relevant_types(
        &self,
        mut context: SemanticContext,
        diagnostic: &Diagnostic,
    ) -> SemanticContext {
        // Extract type names mentioned in the diagnostic message
        let diagnostic_text = &diagnostic.message.to_lowercase();
        let type_keywords = vec!["type", "interface", "struct", "class", "enum", "trait", "impl"];

        // Enhanced heuristics for filtering relevant types
        context.type_definitions.retain(|type_def| {
            let type_name_lower = type_def.name.to_lowercase();
            
            // 1. Direct mention in diagnostic message (case-insensitive)
            if diagnostic_text.contains(&type_name_lower) {
                return true;
            }
            
            // 2. Type name with common prefixes/suffixes in diagnostic
            let type_variations = vec![
                format!("{}s", type_name_lower), // plural
                format!("{}error", type_name_lower),
                format!("{}type", type_name_lower),
                format!("{}trait", type_name_lower),
            ];
            if type_variations.iter().any(|v| diagnostic_text.contains(v)) {
                return true;
            }
            
            // 3. Check if type is mentioned with keywords
            if type_keywords.iter().any(|keyword| {
                diagnostic_text.contains(&format!("{} {}", keyword, type_name_lower)) ||
                diagnostic_text.contains(&format!("{} `{}`", keyword, type_name_lower))
            }) {
                return true;
            }
            
            // 4. Keep types that are close to the diagnostic location (within 20 lines)
            if let Some(line_diff) = diagnostic.range.start.line.checked_sub(type_def.line) {
                if line_diff <= 20 {
                    return true;
                }
            }
            if let Some(line_diff) = type_def.line.checked_sub(diagnostic.range.start.line) {
                if line_diff <= 20 {
                    return true;
                }
            }
            
            // 5. Keep types used in function signature if we have function context
            if let Some(ref func_ctx) = context.function_context {
                if func_ctx.signature.contains(&type_def.name) {
                    return true;
                }
            }
            
            // 6. Keep types that are imported (they're likely relevant)
            if context.imports.iter().any(|import| {
                import.imported_names.contains(&type_def.name)
            }) {
                return true;
            }
            
            // 7. Common error-related type patterns
            let error_patterns = vec!["error", "result", "option", "maybe", "either"];
            if error_patterns.iter().any(|pattern| type_name_lower.contains(pattern)) &&
               diagnostic_text.contains("error") {
                return true;
            }
            
            false
        });

        // Also filter imports to only keep those that are actually used
        let used_type_names: Vec<String> = context.type_definitions
            .iter()
            .map(|t| t.name.clone())
            .collect();
            
        context.imports.retain(|import| {
            // Keep import if any of its imported names are in our filtered types
            import.imported_names.iter().any(|name| {
                used_type_names.contains(name) || 
                diagnostic_text.contains(&name.to_lowercase())
            })
        });

        context
    }

    /// Calculate relevance score for the extracted context
    fn calculate_relevance_score(&self, context: &SemanticContext) -> f32 {
        let mut score = 0.0;
        let mut max_score = 0.0;

        // Function context adds significant value
        if context.function_context.is_some() {
            score += 0.3;
        }
        max_score += 0.3;

        // Class context adds value
        if context.class_context.is_some() {
            score += 0.2;
        }
        max_score += 0.2;

        // Imports and types add value based on quantity
        if !context.imports.is_empty() {
            score += 0.15 * (context.imports.len() as f32 / 10.0).min(1.0);
        }
        max_score += 0.15;

        if !context.type_definitions.is_empty() {
            score += 0.15 * (context.type_definitions.len() as f32 / 5.0).min(1.0);
        }
        max_score += 0.15;

        // Call hierarchy adds value
        if !context.call_hierarchy.calls_outgoing.is_empty() {
            score += 0.1 * (context.call_hierarchy.calls_outgoing.len() as f32 / 5.0).min(1.0);
        }
        max_score += 0.1;

        // Local variables add some value
        if !context.local_variables.is_empty() {
            score += 0.1 * (context.local_variables.len() as f32 / 10.0).min(1.0);
        }
        max_score += 0.1;

        if max_score > 0.0 {
            score / max_score
        } else {
            0.0
        }
    }
}

#[derive(Debug, Clone, Copy)]
enum Language {
    TypeScript,
    Rust,
    Python,
    Unknown,
}

impl Default for SemanticContext {
    fn default() -> Self {
        Self {
            function_context: None,
            class_context: None,
            imports: Vec::new(),
            type_definitions: Vec::new(),
            local_variables: Vec::new(),
            call_hierarchy: CallHierarchy::default(),
            dependencies: Vec::new(),
            relevance_score: 0.0,
            surrounding_code: std::collections::HashMap::new(),
        }
    }
}

impl Default for CallHierarchy {
    fn default() -> Self {
        Self {
            calls_outgoing: Vec::new(),
            calls_incoming: Vec::new(),
            analysis_depth: 0,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::types::{DiagnosticSeverity, Position, Range};

    #[test]
    fn test_filter_relevant_types() {
        let mut extractor = ContextExtractor::new().unwrap();
        
        // Create a diagnostic with a specific error message
        let diagnostic = Diagnostic {
            id: "test123".to_string(),
            file: "test.ts".to_string(),
            message: "Type 'string' is not assignable to type 'UserConfig'".to_string(),
            severity: DiagnosticSeverity::Error,
            range: Range {
                start: Position { line: 10, character: 5 },
                end: Position { line: 10, character: 15 },
            },
            code: None,
            source: "typescript".to_string(),
            related_information: None,
            tags: None,
            data: None,
        };
        
        // Create a context with various type definitions
        let mut context = SemanticContext::default();
        
        // Type directly mentioned in error
        context.type_definitions.push(TypeDefinition {
            name: "UserConfig".to_string(),
            definition: "interface UserConfig { name: string; }".to_string(),
            kind: "interface".to_string(),
            line: 5,
        });
        
        // Type close to error location (within 20 lines)
        context.type_definitions.push(TypeDefinition {
            name: "NearbyType".to_string(),
            definition: "type NearbyType = number;".to_string(),
            kind: "type".to_string(),
            line: 12,
        });
        
        // Type far from error
        context.type_definitions.push(TypeDefinition {
            name: "FarAwayType".to_string(),
            definition: "type FarAwayType = boolean;".to_string(),
            kind: "type".to_string(),
            line: 100,
        });
        
        // Error-related type
        context.type_definitions.push(TypeDefinition {
            name: "ConfigError".to_string(),
            definition: "class ConfigError extends Error {}".to_string(),
            kind: "class".to_string(),
            line: 50,
        });
        
        // Apply filtering
        let filtered = extractor.filter_relevant_types(context, &diagnostic);
        
        // Check results
        // UserConfig should be kept (mentioned in error message)
        assert!(filtered.type_definitions.iter().any(|t| t.name == "UserConfig"));
        // NearbyType should be kept (within 20 lines of error)
        assert!(filtered.type_definitions.iter().any(|t| t.name == "NearbyType"));
        // FarAwayType should NOT be kept (too far from error and not mentioned)
        assert!(!filtered.type_definitions.iter().any(|t| t.name == "FarAwayType"));
        
        // ConfigError is not kept because:
        // 1. It's far from the error (line 50 vs error at line 10)
        // 2. The error message doesn't contain "error" in lowercase
        assert_eq!(filtered.type_definitions.len(), 2);
    }
    
    #[test]
    fn test_filter_keeps_types_in_function_signature() {
        let extractor = ContextExtractor::new().unwrap();
        
        let diagnostic = Diagnostic {
            id: "test456".to_string(),
            file: "test.rs".to_string(),
            message: "mismatched types".to_string(),
            severity: DiagnosticSeverity::Error,
            range: Range {
                start: Position { line: 20, character: 10 },
                end: Position { line: 20, character: 20 },
            },
            code: None,
            source: "rust-analyzer".to_string(),
            related_information: None,
            tags: None,
            data: None,
        };
        
        let mut context = SemanticContext::default();
        
        // Add function context with a type in signature
        context.function_context = Some(FunctionContext {
            name: "process_data".to_string(),
            signature: "fn process_data(config: AppConfig) -> Result<()>".to_string(),
            body: "fn process_data(config: AppConfig) -> Result<()> { todo!() }".to_string(),
            start_line: 15,
            end_line: 25,
        });
        
        // Add type that appears in function signature
        context.type_definitions.push(TypeDefinition {
            name: "AppConfig".to_string(),
            definition: "struct AppConfig { }".to_string(),
            kind: "struct".to_string(),
            line: 50, // Far away but in function signature
        });
        
        // Apply filtering
        let filtered = extractor.filter_relevant_types(context, &diagnostic);
        
        // Should keep AppConfig because it's in the function signature
        assert_eq!(filtered.type_definitions.len(), 1);
        assert_eq!(filtered.type_definitions[0].name, "AppConfig");
    }
    
    #[test]
    fn test_extract_type_references() {
        let mut extractor = ContextExtractor::new().unwrap();
        
        // Test TypeScript type extraction
        let ts_code = r#"
            function processUser(user: UserProfile): ProcessResult {
                const config: AppConfig = getConfig();
                const items: Array<Item> = user.items;
                return { success: true };
            }
        "#;
        
        let tree = extractor.get_parser("typescript")
            .unwrap()
            .parse(ts_code, None)
            .unwrap();
        let root = tree.root_node();
        
        let type_refs = extractor.extract_type_references(&root, ts_code, Language::TypeScript);
        
        // Should extract UserProfile, ProcessResult, AppConfig, and Item (but not Array - builtin)
        assert_eq!(type_refs.len(), 4);
        assert!(type_refs.iter().any(|(name, _)| name == "UserProfile"));
        assert!(type_refs.iter().any(|(name, _)| name == "ProcessResult"));
        assert!(type_refs.iter().any(|(name, _)| name == "AppConfig"));
        assert!(type_refs.iter().any(|(name, _)| name == "Item"));
        assert!(!type_refs.iter().any(|(name, _)| name == "Array")); // Built-in type
    }
}
